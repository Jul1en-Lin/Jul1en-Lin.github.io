[{"content":"验证码功能 引入Hutool工具包 Hutool工具是一个开源的Java工具依赖库，封装了许多功能，访问https://hutool.cn，按图中引入依赖即可使用，具体功能可查看官方文档~\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cn.hutool\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hutool-all\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.42\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 实现功能 以下是参考文档代码，以写出到浏览器（Servlet输出）为栗子\n1 2 3 ICaptcha captcha = ...; captcha.write(response.getOutputStream()); //Servlet的OutputStream记得自行关闭哦！ 执行流程 ==验证码的服务主要由后端实现，前端只负责发起请求，且验证码的答案一般存于内存/Redis中，这里以Hutool工具实现==\n前端发起GET请求 后端： 利用Hutool工具生成一张图片验证码 将验证码密码放入Session / Redis 中，这里放入Session举栗子 加入验证条件：有效时间 前端拿到图片，将用户输入一起POST到后端 后端校验，返回对应的值 细节问题 线程安全 http是无状态的，后端接口之间/captcha/getCaptcha​与/captcha/check是独立的，内容无法共享数据，那需要校验的时候如何拿到验证码呢？\n​/getCaptcha​接口的成员变量与/check是不共享的，以线程安全角度来说，以下两个方法都是不可取的\n直接声明一个成员变量 在类里声明成员变量，如果多次请求/getCaptcha接口，用户1生成了验证码1，用户2生成了验证码2，成员变量验证码1变化为验证码2，如果这时候用户1拿着正确的验证码1进行校验，肯定是失败的\n交给Spring管理 Spring管理的是Bean成员对象，且这个对象是单例的，所以也有线程安全问题\n解决方法 我们可以使用Session存储，Session保证了对话安全，每个用户都有单独的会话id，把验证码存储到Session中，生成与校验都能通过Session操作存入/拿出\n考虑线程安全问题的场景 对象有没有数据共享 主动创建线程（池）的时候 时间戳 项目开发中，时间的处理和表示通常使用时间戳，能解决跨时区的问题，实现了前后端 UI 解耦，计算也更加便捷\n参数配置 学到Spring就要充分用到管理对象的功能，但是有些时候参数的注入过于繁琐，如需要构造一个图片类型的验证码，需要传入width​、height、验证码长度、干扰因子等等，这些固定参数通常需要放到配置文件中管理，起到解耦作用\n那注入这么多参数，代码非常不美观，故又想到将配置参数转换为一个对象，从对象中去取，就更加优雅了~\n举个栗子，这是构造图片验证码的代码\n参数放在application.yaml文件中\n由于注入的时候要一个一个取，非常麻烦，类似于：\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${captcha.width}\u0026#34;) private String width; @Value(\u0026#34;${captcha.height}\u0026#34;) private String height; @Value(\u0026#34;${captcha.codeCount}\u0026#34;) private String codeCount; @Value(\u0026#34;${captcha.lineCount}\u0026#34;) private String lineCount; 创建CaptchaProperties类来对配置对象进行管理\n1 2 3 4 5 6 7 8 9 @Component @Data @ConfigurationProperties(prefix = \u0026#34;captcha\u0026#34;) public class CaptchaProperties { private Integer width; private Integer height; private Integer codeCount; private Integer lineCount; } 在CaptchaController​层面中，构造对象的时候只需注入CaptchaProperties对象，通过取对象中的成员得到值\n1 2 3 4 5 6 @Autowired private CaptchaProperties properties; // 定义图形验证码的长和宽 LineCaptcha captcha = CaptchaUtil.createLineCaptcha(properties.getWidth(), properties.getHeight(), properties.getCodeCount(), properties.getLineCount()); 常量处理 开发中，管理常量的成员一般存入constant​包中，交给Constant类管理\n实现代码 控制层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 @RestController @RequestMapping(\u0026#34;/captcha\u0026#34;) public class CaptchaController { @Autowired private CaptchaProperties properties; // 生成验证码 @RequestMapping(\u0026#34;/getCaptcha\u0026#34;) public void getCaptcha(HttpServletResponse response, HttpSession session) throws IOException { // 定义图形验证码的长和宽 LineCaptcha captcha = CaptchaUtil.createLineCaptcha(properties.getWidth(), properties.getHeight(), properties.getCodeCount(), properties.getLineCount()); //告知浏览器处理响应以作为图片显示 response.setContentType(\u0026#34;image/jpeg\u0026#34;); // 设置session (验证码内容 + 有效时间) session.setAttribute(properties.getSession().getName(),captcha.getCode());// 保存验证码内容 session.setAttribute(properties.getSession().getDate(),System.currentTimeMillis());// 使用时间戳 try { // 验证码写出到浏览器 captcha.write(response.getOutputStream()); } catch (IOException e) { throw new RuntimeException(e); }finally { //Servlet的OutputStream记得自行关闭 response.getOutputStream().close(); } } /** * 如何存储验证码？局部变量nonono！多线程下会修改 * 变成对象交给Spring管理也不行，管理的Bean是单例的，多线程下也能修改 * 把验证码存到session当中，需要用就取出来即可 * @param captcha 用户输入的验证码 * @return 布尔值 */ // 校验验证码 @RequestMapping(\u0026#34;/check\u0026#34;) public boolean check(HttpSession session,String captcha) { if (!StringUtils.hasLength(captcha)) return false; // 获取session内的验证码 String code = (String)session.getAttribute(properties.getSession().getName()); // 获取验证码生成时间 Long captchaTime = (Long)session.getAttribute(properties.getSession().getDate()); if (!StringUtils.hasLength(code) || captchaTime == null) return false; // 校验验证码超时时间——5min 可以使用常量表示5*60*1000 常量类放到constant包中 if (System.currentTimeMillis() - captchaTime \u0026gt; CAPTCHA_TIME_OUT) return false; return captcha.equalsIgnoreCase(code); } } 实例层（ConfigurationProperties、Session）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component @Data @ConfigurationProperties(prefix = \u0026#34;captcha\u0026#34;) public class CaptchaProperties { private Session session; private Integer width; private Integer height; private Integer codeCount; private Integer lineCount; } @Data public class Session { private String name; private String date; } 常量层\n1 2 3 public class Constant { public static final int CAPTCHA_TIME_OUT = 5*60*1000; } ‍\n","date":"2025-12-13T01:02:22+08:00","permalink":"https://Jul1en-Lin.github.io/p/%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/","title":"🧣 验证码功能"},{"content":"自动化测试 自动化测试包括\n接口自动化测试\nUI自动化测试\nWeb自动化测试\n客户端界面自动化测试\n这次来讲讲Web 自动化测试。\n什么是 Web 自动化测试？ 在大厂的研发流程中，自动化测试是**CI/CD（持续集成/持续部署）**不可或缺的一环。\n简单来说，Web 自动化测试就是​把原本需要人工在浏览器上点击、输入、验证的操作，通过代码指令让计算机自动执行。\nSelenium 与 WebDriver 目前业界最主流的 Web 自动化工具就是 Selenium。虽然现在也有 Playwright 等新秀，但 Selenium 依然是很多大厂面试的基石。\nSelenium 是什么？ Selenium 不是一个单一的软件，它是一个工具套件。核心组件是 ​Selenium WebDriver。\n它提供了一套跨语言的 API（Java, Python, C#, etc.）。 它通过“原生”方式与浏览器交互，就像真实用户在操作一样。 WebDriver 的工作原理（面试） 这是Selenium官方文档对WebDriver的介绍\n理解了这个图，你就懂了为什么需要下载“驱动”。\n它的运作流程是一个经典的“C/S 架构”（客户端/服务器）：\nClient（你的代码）： 你写的 Java 代码（发送命令，比如 driver.get(\u0026quot;www.baidu.com\u0026quot;)）。 JSON Wire Protocol / W3C Protocol： 代码将命令封装成 JSON 格式的 HTTP 请求，发送给驱动。 Server（浏览器驱动）： 比如 chromedriver.exe。它接收到 HTTP 请求后，解析命令，并调用浏览器的原生接口。 Browser（浏览器）： 执行操作（打开网页、点击按钮），并将结果返回给驱动，驱动再返回给你的代码。 ‍\nSelenium与WebDriver的关系？（面试） Selenium 是一个工具集，而 WebDriver 是其中用于通过原生协议驱动浏览器的核心 API。现在我们常说的 Selenium，通常默认指的就是 Selenium WebDriver。\n安装Selenium库 安装Selenium在Java中只需引入Maven依赖即可\n1 2 3 4 5 6 7 \u0026lt;!-- https://mvnrepository.com/artifact/org.seleniumhq.selenium/selenium-java --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.37.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // version 2025.12.6 Selenium内置了 WebDriver 的 API，但它不包含浏览器驱动文件（exe），故需要手动下载 / 自动下载驱动\n程序想打开web浏览器就需要浏览器驱动，即（WebDriver），WebDriver以本地化的方式来驱动浏览器\n关于“驱动” (Drivers) 浏览器驱动（BrowserDriver）是你的代码和浏览器之间的桥梁。\n为什么需要驱动？ 浏览器（Chrome, Firefox等）都是复杂的闭源或开源软件，出于安全考虑，不允许外部程序直接随意控制。浏览器厂商（Google, Mozilla）为了方便测试，自己开发了对外接口的“遥控器”，这个遥控器就是 Driver。\n常见浏览器与驱动对应表 浏览器 驱动名称 下载关键词 Google Chrome ChromeDriver ​chromedriver Firefox GeckoDriver ​geckodriver Microsoft Edge EdgeDriver ​msedgedriver 驱动版本适配管理（重点） 版本匹配原则：这是新手最容易报错的地方。\n你的 Chrome 浏览器版本 必须与 ChromeDriver 版本 严格对应。例如，浏览器是 v120，驱动也必须下载 v120 版本的。否则会报错 SessionNotCreatedException。\n我们可以在浏览器内查看当前浏览器版本，安装的selenium 驱动版本，可以在本地c盘用户的C:\\Users\\xxx.cache文件下看到selenium文件夹，里面安装着不同的内核版本\n常见驱动下载方式 1. 手动下载（不建议） （注：虽然可以有程序自动管理驱动，但了解手动匹配依然是基础)\n下载驱动的位置在Selenium官方文档中有提供，地址为\n​https://www.selenium.dev/documentation/webdriver/troubleshooting/errors/driver_location/#download-the-driver\n不建议手动下载，因为浏览器的更新功能是默认打开的，什么时候更新是不知道的。可能今天自动化正常执行，第二天就要重新下载最新版的驱动了，且不同的浏览器就要我们手动下载不同的驱动，非常麻烦。\n这也不建议手动关闭浏览器的自动更新功能，不仅测试环境与生产环境有脱节，错过了新的自动化的功能或者改进的地方，而且可能导致Selenium库与旧的浏览器版本兼容，这种头疼砍头的操作不可取。\n2. 由驱动程序自动下载 （注：Selenium 4.6.0 版本开始引入了 Selenium Manager，可以自动管理驱动，但了解WebDriverManager也是非常重要的基础）\n更好的做法不是禁用更新，而是采用更健壮的测试策略\n需要引入WebDriverManager辅助工具库\n用途：它可以让你不用手动去浏览器官网找对应版本的驱动下载，它会在代码运行时自动检测浏览器版本并下载对应的驱动。 引入WebDriverManager依赖\n1 2 3 4 5 6 7 \u0026lt;!-- https://mvnrepository.com/artifact/io.github.bonigarcia/webdrivermanager --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.bonigarcia\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;webdrivermanager\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; // version 2025.12.6 3. 更新Selenium库至 4.6+ 版本 适用于更加新的项目，直接 new Driver()， Selenium就能给你匹配最新的驱动版本\nSelenium文档中的描述\n传统方案： 使用 webdrivermanager 第三方库。适合维护旧项目（Selenium 3.x 或 4.x 早期版本）\n1 2 3 // 传统方案 WebDriverManager.chromedriver().setup(); // 手动呼叫后勤 WebDriver driver = new ChromeDriver(); 现代方案： 直接使用 selenium-java​ (4.6+)，利用内置的 Selenium Manager，实现零辅助库配置启动\n1 2 3 // 什么都不用配，直接 new // 底层会自动触发 Selenium Manager 去干活 WebDriver driver = new ChromeDriver(); 总结 我用Banana Pro生成了这一副插画，能更加形象的了解Web自动化测试执行的逻辑😽\nWeb自动化常用函数 🙈与其像流水账一样罗列 API，不如按照“业务场景”或者“对象层级”来分类\n浏览器级的操作（Driver） 这部分方法是直接作用于WebDriver​对象的，控制着浏览器的生命周期与状态，通常用于测试开始前的准备（Setup）或测试结束后的清理（Teardown），以及用于 “断言” 的前置检查。\n获取页面信息 （用于断言）\n在自动化测试中，我们怎么知道脚本是不是跳转到了正确的页面？靠的就是这两个方法：\n​​driver.getTitle()​\n​介绍：获取当前浏览器窗口标签页上的标题文本。 用途：这是最常用的断言点。比如登录成功后，验证标题是否包含“个人中心”或“首页” 注意：如果新开窗口后没有切换driver，则driver依旧作用在旧窗口，识别不了另一个窗口的信息，如有需要用到切换窗口的方法，这就引出获取当前 / 所有句柄id\n​​driver.getCurrentUrl()​\n​介绍：获取浏览器地址栏当前的 URL 字符串。 用途：验证重定向是否正确。比如支付完成后，URL 是否跳转到了 /success 页面。 ​​driver.getWindowHandle() / getWindowHandles()​\n介绍：获取句柄（标签页）id\n用途：一般搭配切换句柄的操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // getWindowHandle 获取driver当前标签页/句柄id String window = driver.getWindowHandle(); System.out.println(\u0026#34;window: \u0026#34; + window); // getWindowHandles 获取所有标签页/句柄id driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;s-top-left\\\u0026#34;]/a[6]\u0026#34;)).click(); Set\u0026lt;String\u0026gt; handles = driver.getWindowHandles(); // 切换窗口操作 for (String handle : handles) { if (!window.equals(handle)) { driver.switchTo().window(handle); } } String jump_title = driver.getTitle(); String jump_url = driver.getCurrentUrl(); System.out.println(\u0026#34;jump_title：\u0026#34; + jump_title); System.out.println(\u0026#34;jump_url：\u0026#34; + jump_url); // 这样就能正确切换窗口且得到新窗口的title 和 url 浏览器窗口调整\n​​driver.manage().window().maximize()​ ​ / ​.setSize(里面需传入Dimension对象，手动规定尺寸)​ ：\n介绍：自动化脚本启动时，默认通常是小窗口。\n​用途：\n​全屏​：通常建议在 driver​ 初始化后立即调用 maximize()，因为很多网页在小窗口下会折叠菜单（变成汉堡按钮），导致元素不可见或定位失败。 ​指定尺寸​：在测试“响应式布局”时，通过 setSize() 模拟手机或平板的分辨率。 浏览器的关闭 （面试）\n​​driver.close()​ ：\n介绍：仅仅关闭当前正在操作的那个标签页（Tab）或窗口 注意：如果当前浏览器只有一个窗口，调用它也会导致浏览器退出，但它不会清除驱动进程。 避坑点： 当调用 driver.close()​ 关闭当前标签页后，WebDriver 并不会自动把焦点切换回剩下的那个标签页\n解决办法：\n在 close 前保存下当前句柄 id，然后删除后便于 driver 切换新的标签页（适用于随便去一个活着的窗口的情况）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 driver.get(\u0026#34;https://www.baidu.com/\u0026#34;); // 新开百度图片标签页 driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;s-top-left\\\u0026#34;]/a[6]\u0026#34;)).click(); // 删除当前标签页后 driver 指向空，无法对新开的百度图片标签页进行操作 // 故需要在关闭标签页后切换句柄 使driver对象指向新的句柄 String windowHandle = driver.getWindowHandle(); Set\u0026lt;String\u0026gt; windowHandles = driver.getWindowHandles(); driver.close(); // 无法直接获得新的句柄的title 必须使driver切换句柄 // System.out.println(driver.getTitle()); // error~~ // 需要切换句柄 for (String handle : windowHandles) { if (!handle.equals(windowHandle)) { driver.switchTo().window(handle); break； } } System.out.println(driver.getTitle()); // success~~ Parent-Child 模式（标准）\n在实际业务测试中（如：在列表页点击商品 -\u0026gt; 弹出新标签页详情 -\u0026gt; 验证完关闭详情 -\u0026gt; 回到列表页继续点下一个）需要“从哪里来，回哪里去”的逻辑，更有目的性地跳回\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 场景：在 首页(A) 点击链接打开了 详情页(B)，处理完 B 后关闭并回到 A // 1. 【核心】在这一刻，Driver 还在 A 页面，先保存 A 的身份证 String originalWindowHandle = driver.getWindowHandle(); // 2. 执行打开新页面的操作 driver.findElement(By.id(\u0026#34;open-new-tab-link\u0026#34;)).click(); // 3. 切换到新窗口 (这里假设只要不是原窗口就是新窗口) for (String handle : driver.getWindowHandles()) { if (!handle.equals(originalWindowHandle)) { driver.switchTo().window(handle); break; // 切过去就不动了 } } // --- 此时 Driver 已经在 B 页面了 --- System.out.println(\u0026#34;在新页面操作: \u0026#34; + driver.getTitle()); // 4. 业务结束，关闭当前的新页面 B driver.close(); // ⚠️ 此时 Driver 是悬空的，指向一个不存在的 B // 5. 【核心】显式切换回原窗口 A driver.switchTo().window(originalWindowHandle); // --- 此时 Driver 又回到了 A 页面，复活了 --- System.out.println(\u0026#34;回到原页面: \u0026#34; + driver.getTitle()); ​​driver.quit()​ ：\n介绍：彻底关闭整个浏览器，关闭所有打开的标签页，并销毁 ChromeDriver 进程。 注意：在自动化测试框架的 ​finally​​ 块或 ​@After​​ 钩子中，必须使用 ​quit()​ ​ ，否则你的服务器内存会被浏览器进程吃光。强调资源释放的重要性！ 对元素级操作（Element） 需要先通过 driver.findElement()​ 找到元素WebElement后才能调用后续的方法。这是自动化测试中最繁忙的部分，简单来讲就是模拟人类的手指的各种操作\n输入与交互\n​​element.sendKeys(\u0026quot;text\u0026quot;)​ ：\n​介绍：模拟键盘向输入框输入指定内容。 ​高阶用法​：它不仅能输入文字，还能用于​文件上传​（如果 input 类型是 file，直接 sendKeys 文件路径即可），或者模拟按键（如 Keys.ENTER）。 ​​element.clear()​ ：\n介绍：清空输入框中的已有文本。 避坑：在调用 sendKeys​ 之前，建议先调用 clear()​。因为如果输入框有默认值，sendKeys 会直接追加在后面，导致数据错误。如：\n1 2 3 4 5 6 7 // 如果不进行clear操作，则会在“gpt”文本后追加“chrome”文本 driver.get(\u0026#34;https://www.baidu.com/\u0026#34;); driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;chat-textarea\\\u0026#34;]\u0026#34;)).sendKeys(\u0026#34;gpt\u0026#34;); // 应该clear上一次的文本 // driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;chat-textarea\\\u0026#34;]\u0026#34;)).clear(); driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;chat-textarea\\\u0026#34;]\u0026#34;)).sendKeys(\u0026#34;chrome\u0026#34;); driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;chat-submit-button\\\u0026#34;]\u0026#34;)).click(); ​​element.click()​ ：\n​介绍：模拟鼠标左键点击。 ​适用：不仅是按钮，超链接、复选框、单选按钮，甚至普通的文本（如果有点击事件）都可以点。 获取元素信息\n​​element.getText() / .getAttribute(\u0026quot;value\u0026quot;)​ ：\n​介绍​：获取元素标签对之间的​可见文本。 ​用途：这是验证测试结果的核心。比如下单成功后，获取页面上的提示语“支付成功”，与预期结果进行比对。 注意：如果元素在页面上被隐藏（Hidden），这个方法通常会返回空字符串。 避坑点： 如果为了获取输入框里用户输入的值，用 getText()​ 是拿不到的，必须用 getAttribute(\u0026quot;value\u0026quot;)\n比如想获取红色框的文字，定位这元素所在的位置\n发现文字是在placeholder​属性内的，必须要用getAttribute(\u0026quot;placeholder\u0026quot;)才能拿到！\n​getText()​适合用在\u0026lt;标签\u0026gt; \u0026ldquo;xxxx\u0026rdquo; \u0026lt;标签\u0026gt;被标签内包裹的文本信息，如\n窗口与句柄切换 ​​driver.switchTo().window(handle)​ ：\n​核心概念——句柄 (Handle) ：每个标签页都有一个唯一的身份证号，叫句柄。\n场景：当点击了一个链接，浏览器打开了一个新的标签页。此时虽然人眼看到了新页面，但 driver​ 的焦点还停留在旧页面上。如果直接操作新页面的元素，会报错：NoSuchElementException\n​操作逻辑：\n获取所有窗口的句柄：driver.getWindowHandles()。 遍历这些句柄，排除掉当前句柄。 使用 switchTo().window(新句柄) 将控制权移交到新页面。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // getWindowHandle 获取driver当前标签页/句柄id String window = driver.getWindowHandle(); System.out.println(\u0026#34;window: \u0026#34; + window); // getWindowHandles 获取所有标签页/句柄id driver.findElement(By.xpath(\u0026#34;//*[@id=\\\u0026#34;s-top-left\\\u0026#34;]/a[6]\u0026#34;)).click(); Set\u0026lt;String\u0026gt; handles = driver.getWindowHandles(); // 切换窗口操作 （随机切换式） for (String handle : handles) { if (!window.equals(handle)) { driver.switchTo().window(handle); break; } } // 这样就能正确切换窗口 ‍\n","date":"2025-12-12T17:16:00+08:00","image":"https://Jul1en-Lin.github.io/p/web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/assets/image-20251206161502-kow88l3_hu_387147997cab41eb.png","permalink":"https://Jul1en-Lin.github.io/p/web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"🎓 Web自动化测试"},{"content":"开发模型和测试模型 开发模型 学习测试，我们需要了解产品的开发流程，开发模型实际上指的就是产品的开发流程\n瀑布模型 瀑布模型是其他模型的基础框架，它是最基础的模型，模型如图所示\n特点 / 优点：\n开发流程是线性的，每个阶段执行一次就结束 适合小项目的开发 缺点：\n交付时间长，需要很久才能看到产品 测试阶段执行晚，如果一个需求引入的缺陷要到测试阶段或更晚的阶段才能看到，可能会导致前面的工作大面积的返工 螺旋模型 它与瀑布模型的不同是在需求分析到编码环节都进行风险分析，评估方案后才进入下一级产品\n特点 / 优点：\n强调开发中各个环节的质量 严格的风险管理 增加风险分析与原型 适合规模庞大、复杂度高、风险大的项目 缺点：\n开发成本增高，人员、资金、时间的投入 项目中存在的风险性与风险管理人员的水平有直接的关系 增量模型 / 迭代模型 它的核心思想是不要一次性把系统全部做完，而是分阶段地、分模块地逐步完善。\n每一次的构建（称为 “增量“）都在上一个版本的基础上进行完善与扩展；每一次的迭代都包括开发 → 测试 → 反馈 → 修正的完整过程。\n“增量”强调的是量的增长（功能一点点加）； “迭代”强调的是质的改进（版本不断优化）\n想象你在搭建一座乐高城堡。你不会一次性把所有零件拼完，而是先搭出地基，再加上城门、塔楼、装饰。每加完一部分（增量），你都会检查它是否稳固、是否和之前的部分契合（迭代）。\n这样，当城堡最终完工时，它不仅完整，而且每一层都经过了检验。\n特点 / 优点：\n每个增量都要单独测试，保证它稳定、可集成 每次迭代都能提前发现风险 测试结果反过来指导下一轮开发 适用于大项目且需求不明确的情况 缺点：\n如果项目的方向控制不严，就可能陷入反复重构、推倒重来的恶性循环，尤其在客户频繁修改需求时，团队可能永远都在“打补丁”，而不是向最终目标靠近。 系统整体性不易把握，后期可能会出现接口不兼容，模块耦合度过高等问题 管理和测试成本增高，每一次迭代都需要经过一次完整的开发、测试、评审、部署流程 增量模型 可能先上线一部分的功能 / 模块，后续再进行完善，上线顺序可能是 模块1 -\u0026gt; 功能1 -\u0026gt; 功能2 -\u0026gt; 功能3 -\u0026gt; 功能4 -\u0026gt; 模块2\n迭代模型 敏捷模型 敏捷模型的特点是：轻文档、轻流程、重目标，重产出。\nScrum模型就是敏捷模型中的一种，又称为迭代式增量软件开发模型，可以看成迭代模型与增量模型的结合。\nscrum的基本流程如图所示\n‍\n软件测试 软件测试的最终目的是验证产品​==特性==​是否满足客户需求~\n软件测试贯穿于软件的整个生命周期~（非常重要！！！！！面试可以装杯）\n🤔延申问题：如何理解软件测试贯穿于软件的整个生命周期~ 这句话？\n先来看软件的生命周期，才能更好的理解软件测试的生命周期\n软件的生命从需求分析就开始了，一直到上线维护\n软件测试的生命周期也从需求分析开始，虽然说在软件声明周期内测试是排在编码之后，但是软件测试的内容从需求分析就开始了，故说 ==软件测试贯穿于整个软件的生命周期！==\n需求分析：从用户角度（软件需求是否合理）、技术角度（技术上是否可行）、测试角度（是否存在业务逻辑错误、冲突等问题）分析 测试计划：指定测试计划——什么时候开发测试，什么时候结束测试，耗时需要多久 测试设计、开发：参考需求文档、技术文档等，来编写测试用例；编写测试文档，明确标注用到的测试方法，测试工具，测试形式等（输出测试设计） 测试执行：充分利用测试用例与工具，尽可能的做到全方面覆盖测试 测试评估：测试是否通过，本次测试是否有遗留BUG，产出测试报告——描述清楚测试的进度、项目进度，得出测试结论：是否具备上线条件 上线：上线后，测试人员跟踪并测试线上环境，确保运行是否正常 运行维护：在运行项目时收集问题并反馈相关负责人 测试模型 测试中有两个重要且标志性的测试模型：V 模型与 W 模型\nV模型 其中测试环节中的单元测试与集成测试一般是由开发人员来测试，单元测试的单元是人为规定的，可以认为是某个接口 / api / 方法 / 类\n它也是基于瀑布模型的，所以缺点也是测试后置，导致风险到后期才发现\n我们希望给测试留有充足的时间，否则会把缺点直接暴露到线上\nW模型 在 W 模型中，V 模型的测试后置的问题得到了解决，如图所示\n特点：\n测试与开发是同步进行的，测试的对象也不仅仅是程序，需求、设计等同样需要测试，有利于能尽早发现问题 缺点：\n注重流程，无法支持敏捷开发的模式，灵活性低 无论是测试线还是开发线，都是线性的，直到上一阶段的完全结束才能开始下一阶段的工作 ‍\n","date":"2025-12-11T17:24:01+08:00","image":"https://Jul1en-Lin.github.io/p/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/assets/image-20251102111456-fmja664_hu_d43fdab425039ad1.png","permalink":"https://Jul1en-Lin.github.io/p/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B/","title":"🌵 开发模型与测试模型"},{"content":"Spring 两个核心思想：IoC \u0026amp; DI 和 AOP\nIoC \u0026amp; DI IoC全名为Inversion of Control，即“控制反转”，何为控制反转呢？\n控制：指的是对象的创建、初始化、销毁和生命周期的管理权\n反转：指这种管理权发生了反转：\n传统模式：一般是由程序员来手动new创建对象、并管理依赖，类似UserController user = new UserController() IoC模式：对象的创建和依赖的注入权交给Spring来管理。程序不再由程序员主动来创建，而是被动等待Spring容器将所需的对象注入 / 提取出来 SpringIoC作为一个容器，它管理（装）的是对象（Bean），通过注解将对象交给Spring管理，有两类注解：\n类注解：@Controller @Service @Repository @Configuration @Component 方法注解：@Bean Q：为什么需要这种模式？\nA：目的是为了解耦合，将对象的创建权交给Spring，各个组件之间不再强依赖，使得代码更加容易维护、管理与扩展\n这里有简单的代码实力，对比传统模式与IoC模式的区别：假设我们有一个用户服务 (​​UserService​​ ) ，它需要调用数据访问层 (​​UserDao​​ ) 来把用户信息保存到数据库\n传统模式：在这种模式下，UserService​ 自己负责创建它需要的依赖对象。\n1 2 3 4 5 6 7 8 9 10 public class UserService { // ❌ 缺点：高度耦合 // UserService 必须明确知道 UserDao 的具体实现类是哪个 (UserDaoImpl) // 如果将来想换成 UserDaoNewImpl，必须修改这里的代码 private UserDao userDao = new UserDaoImpl(); public void saveUser(String name) { userDao.add(name); } } 控制权： 在程序员手中。你必须手动写 new UserDaoImpl()。 问题： 代码“写死”了。如果你想做单元测试（Mock 一个假的 UserDao），非常困难。 Spring IoC模式（依赖注入）：在这种模式下，UserService​ 只定义它需要什么，而不关心对象是怎么来的。Spring 容器负责把对象“递”进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service // 1. 告诉 Spring：这个类交给你管理，它是一个 Bean（对象） public class UserService { // ✅ 优点：解耦 // UserService 只知道它需要一个 UserDao 接口 // 具体是哪个实现类，由 Spring 容器自动注入 @Autowired private UserDao userDao; public void saveUser(String name) { userDao.add(name); } } 控制权： 在 Spring 容器手中（反转了）。\n发生了什么：\nSpring 扫描到 @Service​，创建并管理了 UserService 的实例。 Spring 看到 @Autowired​，发现 UserService​ 需要一个 UserDao。 Spring 在自己的容器里找到合适的 UserDao​ 实例，直接注入（赋值）给 userDao 变量。 前提是UserDao​也需要被Spring管理，数据层一般添加@Repository注解管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.springframework.stereotype.Repository; // 1. 定义接口 public interface UserDao { void add(String name); } // 2. 实现接口，并加上 @Repository 注解 @Repository public class UserDaoImpl implements UserDao { @Override public void add(String name) { // 模拟数据库操作 System.out.println(\u0026#34;保存用户到数据库: \u0026#34; + name); } } 看到这会疑惑为什么要专门写一个UserDao​接口，然后专门交给UserDaoImpl来实现？\n简短的回答是：\n从技术上讲，完全可以不写接口，直接定义一个 UserDao​ 类并加上 @Repository，Spring 照样能工作\n但是使用接口+实现类的模式主要有以下优点：\n这是面向对象设计（SOLID 原则）中的 D (Dependency Inversion Principle)思想——上层模块（Service）不应该依赖于下层模块（DAO）的具体实现，而应该依赖于抽象（接口）。\n​UserService​只需要知道有UserDao​接口，只需要调用UserDao接口内的方法就好了，但具体怎么实现的则不需要知道（是用 MySQL 写的，还是用 Oracle 写的，或者是把数据写到了 Redis 里）\n举例： 如果有一天你需要把数据库从 MySQL 换成 MongoDB，你只需要新写一个 UserDaoMongoImpl​ 实现接口，而不需要修改 UserService 的任何一行代码。\nSpring AOP的原因\nAOP的底层原理是动态管理\nJDK动态代理（标准）\n只能代理接口，如果Bean对象实现了接口，Spring会默认使用JDK动态代理，效率高，原生支持好\nCGLIB代理（第三方）\n如果Bean对象没有实现接口，只是代理了一个普通的类，Spring就必须使用第三方CGLIB库，继承你的类并重写方法来生成代理\n虽然现在SpringBoot能很好的解决这一类问题，但使用接口配合JDK动态管理已经成为了一种惯例\n💫ORM框架的特殊需求（如MyBatis、JPA）\n如果使用的是MyBatis或Spring Data JPA，那就只需要写接口，连实现类都不用写\nMyBatis：你定义UserMapper接口，MyBatis会自动生成代理对象执行SQL JPA：你定义UserRepository​接口，继承JpaRepository，Spring Data自动帮你生成增删改查的实现 在这种情况下，实现接口是必须的，因为实现类是由框架在运行时动态生成的，你也无法去写一个具体的类\n五大注解详解 类注解：@Controller @Service @Repository @Configuration @Component 方法注解：@Bean 着重讲一下类注解，能发现这有五种不同的类注解，但都能交给Spring管理，那他们的区别是什么呢？\n不同的类注解从名字上就能看出主要应用在哪个层，最基本的项目开发都会有 “控制层—\u0026gt;服务逻辑层—\u0026gt;数据层” 的结构，如果更加复杂的项目开发分开的更加细致，所以不同的注解名字也能第一眼就能看出这个对象主要在哪个层在工作\n基本关系为： 控制层调用服务层，服务层调用数据层，数据层返回结果给服务层，服务层再返回结果给控制层。\n@Controller：控制层——接受参数，返回响应（前后端交互的入口）\n@Service：业务逻辑层\n@Repository：数据层\n@Configuration：配置层\n@Component：组件层——除此以外的所有需要交给Spring管理的对象都能用此注解\n我们扒开源码查看，能看出他们之间的关系\n其中@Controller @Service @Repository @Configuration 都实现了@Component，它们都是@Component的衍生注解\n在实际应用中，这五个注解的边界并没有这么清晰，但控制层必须使用@Controller，不可以和其他注解替换\nBeanName 在Spring容器中取出对象时会使用对应的BeanName，类注解与方法注解都有不同的BeanName命名方法\n五大类注解\nBeanName默认为类名的小驼峰写法，如果类名前两位字母均为大写则BeanName为类名本身，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Controller public class UserController { public void print() { System.out.println(\u0026#34;do controller\u0026#34;); } } public static void main(String[] args) { /** * 获取 bean 的命名方式 * 首字母需变小写 * 如果连续两个大写字母开头则直接写 */ ApplicationContext run = SpringApplication.run(SpringIocApplication.class, args); UserController bean = (UserController) run.getBean(\u0026#34;userController\u0026#34;); bean.print(); } 方法注解@Bean\n需要搭配五大注解使用，BeanName为默认方法名，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component public class StudentComponent { @Bean public Student s1 () { return new Student(\u0026#34;lili\u0026#34;,9); } @Bean public Student s2 () { return new Student(\u0026#34;Jack\u0026#34;,25); } } public static void main(String[] args) { /** * 同时在注解中也提供了对类 / 方法进行重命名 * 包括 @Controller @Service @Configuration @Repository @Component @Bean * 注解后对应的类名 / 方法名则无效 * 只能填重命名后的 * @Bean(\u0026#34;aaa\u0026#34;) * public Student s2 () { * return new Student(\u0026#34;Jack\u0026#34;,25); * } * 如果是run.getBean(\u0026#34;s2\u0026#34;) 报错：NoSuchBeanDefinitionException */ Student s = (Student)run.getBean(\u0026#34;s2\u0026#34;); System.out.println(s); } DI详解 与之IoC匹配的就是DI，DI全名为Dependency Injection，即依赖注入，既然有IoC管理，那就会有DI从Spring容器中取出来，DI就是承担这样的角色——DI 是 IoC 的一种具体实现方式，也能理解为：容器通过注入依赖来实现控制反转，依赖注入是一个过程\nDI分三种方式注入 属性注入 构造方法注入 Setter注入 属性注入 属性注入是通过@Autowired​实现的。如果有多个属性需要逐行注入。@Autowired只对紧挨着那一行代码生效\n构造方法注入 如果只有一种构造方法，则执行这一种构造方法，无论是有参构造还是无参构造\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private UserService service; public UserController(UserService userService) { System.out.println(\u0026#34;执行有参构造方法\u0026#34;); this.service = userService; } public void print() { service.print(); System.out.println(\u0026#34;do controller\u0026#34;); } // 启动项 UserController bean = text.getBean(UserController.class); bean.print(); // 运行结果 // 执行有参构造方法 // do service // do controller 执行成功，print()​拿到service对象\n‍\n如果有多种构造方法，则默认执行无参的构造方法\n存在无参的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private UserService service; private UserRepository repository; public UserController(UserService userService,UserRepository userRepository) { System.out.println(\u0026#34;执行有参构造方法1\u0026#34;); this.service = userService; this.repository = userRepository; } public UserController(UserService userService) { System.out.println(\u0026#34;执行有参构造方法2\u0026#34;); this.service = userService; } public UserController() { System.out.println(\u0026#34;执行无参构造方法\u0026#34;); } public void print() { service.print(); repository.print(); System.out.println(\u0026#34;do controller\u0026#34;); } // 启动项 UserController bean = text.getBean(UserController.class); bean.print(); 由于执行的是无参的构造方法， print()​方法拿不到service​和repository对象，故报错\n如果不存在无参构造方法，则直接报错。报错日志为：找不到默认的构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 private UserService service; private UserRepository repository; public UserController(UserService userService,UserRepository userRepository) { System.out.println(\u0026#34;执行有参构造方法1\u0026#34;); this.service = userService; this.repository = userRepository; } public UserController(UserService userService) { System.out.println(\u0026#34;执行有参构造方法2\u0026#34;); this.service = userService; } // public UserController() { // System.out.println(\u0026#34;执行无参构造方法\u0026#34;); // } public void print() { service.print(); repository.print(); System.out.println(\u0026#34;do controller\u0026#34;); } // 启动项 UserController bean = text.getBean(UserController.class); bean.print(); 可以通过@Autowired 注解来指定构造方法，此时1. 和 2. 的情况都能解决，没有无参构造方法也不会报错，这两种情况都能运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 private UserService service; private UserRepository repository; @Autowired public UserController(UserService userService,UserRepository userRepository) { System.out.println(\u0026#34;执行有参构造方法1\u0026#34;); this.service = userService; this.repository = userRepository; } public UserController(UserService userService) { System.out.println(\u0026#34;执行有参构造方法2\u0026#34;); this.service = userService; } public UserController() { System.out.println(\u0026#34;执行无参构造方法\u0026#34;); } public void print() { service.print(); repository.print(); System.out.println(\u0026#34;do controller\u0026#34;); } // 运行结果 // 执行有参构造方法1 // do service // do repository // do controller ​@Autowired 就是明确该使用哪个构造方法的\nSetter注入 ​Setter​ 注入和属性的Setter ​方法实现类似，只不过在设置 set​ 方法的时候加上@Autowired 注解，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Setter 方法注入 private UserService service; private UserRepository repository; @Autowired public void setUserService(UserService service) { this.service = service; } @Autowired public void setUserService(UserRepository repository) { this.repository = repository; } public void print() { service.print(); repository.print(); System.out.println(\u0026#34;do controller\u0026#34;); } 三种注入的优缺点 属性注入\n优点：简洁，使用方便\n缺点：\n不能注入​​final​​修饰的属性——​final​​的属性有要求，一定需要初始化。要么在属性注入的时候进行初始化，要么在构造方法中进行初始化，但这都违背了注入的初衷：只想从Spring容器中取出来，不想手动初始化，否则我用​​@Autowired​​就没意义了\n构造方法注入\nSpring官方团队（以及Idea的提示）目前最推荐使用的是“构造器注入”\n优点：\n可以注入​​final​​修饰的属性——可以在构造方法中进行初始化，也是解决​​final​​必须初始化的要求\n注入的对象不会被修改，除非有​​set​​方法再对对象修改，否则初始化后就定好了\n通用性好：构造方法是JDK支持的，所以更换任何框架都是使用的\n**依赖对象在使用前一定被完全初始化，因为依赖是在类的构造方法中执行的，而构造方法是在类加载的阶段就会被执行——**​从控制台也能简单看出来，先执行构造方法后再运行服务器\n缺点：注入多个对象时，代码比较繁琐\nSetter注入\n优点：方便在类实例后，重新对该对象进行配置或注入\n缺点：\n不能注入​​final​​修饰的属性\n注入对象可能会被修改，因为提供了setter方法，就有可能被多次调用修改的风险——==这也对应了构造方法的优点：注入的对象不会被修改==\n@Autowired存在的问题 当同一个类型存在多个Bean​时，使用@Autowired会存在问题，示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Service public class UserService { @Autowired private Student ss; public void print() { System.out.println(ss); System.out.println(\u0026#34;do service\u0026#34;); } } @Component public class StudentComponent { @Bean(\u0026#34;bbb\u0026#34;) public Student s1 () { return new Student(\u0026#34;lili\u0026#34;,9); } @Bean(\u0026#34;ccc\u0026#34;) public Student s2 () { return new Student(\u0026#34;Jack\u0026#34;,25); } } 能看到报错原因是，非唯一的Bean对象，Spring无法分辨该把哪个对象注入\n如何在不删除Bean对象的前提下，解决上述问题呢？Spring给了三种注解\n​@Primary ​@Qualifier ​@Resource ​@Primary​：当存在多个相同类型的Bean​注入时，加上@Primary，确认默认的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Service public class UserService { @Autowired private Student ss; public void print() { System.out.println(ss); } } @Component public class StudentComponent { @Bean @Primary // 指定该Bean为默认Bean的实现 public Student s1 () { return new Student(\u0026#34;lili\u0026#34;,9); } @Bean public Student s2 () { return new Student(\u0026#34;Jack\u0026#34;,25); } } // 输出结果 // Student(name=lili, age=9) ​@Qualifier​：指定当前Bean​的对象，在@Qualifier​的value​属性注入Bean​的名字 （默认也是value，内部只有一个String value）\n不能单独使用，需要配合​ ​@Autowired​\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Service public class UserService { @Autowired @Qualifier(\u0026#34;s2\u0026#34;) private Student ss; public void print() { System.out.println(ss); } } @Component public class StudentComponent { @Bean public Student s1 () { return new Student(\u0026#34;lili\u0026#34;,9); } @Bean public Student s2 () { return new Student(\u0026#34;Jack\u0026#34;,25); } } // 输出结果 // Student(name=Jack, age=25) ​@Resource​：按照Bean​的名称进行注入，通过@Qualifier​里的name​属性注入Bean的名字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Service public class UserService { // @Autowired // @Qualifier(\u0026#34;s2\u0026#34;) @Resource(name = \u0026#34;bbb\u0026#34;) private Student ss; public void print() { System.out.println(ss); } } @Component public class StudentComponent { // 作用是一样的 // @Bean({\u0026#34;bbb\u0026#34;,\u0026#34;ccc\u0026#34;}) // @Bean(value = {\u0026#34;bbb\u0026#34;,\u0026#34;ccc\u0026#34;}) @Bean(\u0026#34;bbb\u0026#34;) public Student s1 () { return new Student(\u0026#34;lili\u0026#34;,9); } @Bean public Student s2 () { return new Student(\u0026#34;Jack\u0026#34;,25); } } // 输出结果 // Student(name=lili, age=9) // 注意，使用重命名则原来方法命名就会失效，@Resource(name = \u0026#34;s1\u0026#34;)会报错 常见面试题 @Autowired 与 @Resource 的区别\n​@Autowired​ 是Spring框架提供的注解，@Resource 是JDK提供的注解\n​@Autowired​默认是按照类型注入，@Resource​除了匹配类型，默认按照名称注入。相比于@Autowired​ ，@Resource​ 支持更多的参数设置，例如name​设置，根据名称来获取Bean\n三种注入的优缺点\n常见注解有哪些？分别是什么作用？\nweb URL 映射：@RequestMapping\n参数接收和接口响应：@RequestParam，@RequestBody，@ResponseBody\nBean 的存储：@Controller，@Service，@Repository，@Configuration，@Component，@Bean\nBean 的获取：@Autowired，@Qualifier，@Resource\nSpring、SpringMVC、SpringBoot之间的关系与区别\n@Autowired的装配顺序 Spring、SpringMVC、SpringBoot之间的关系与区别 Spring在不同的角度回答也不同，分Spring和SpringFramework\nSpring：是Spring家族生态 SpringFramework：是核心容器 ‍\nSpring (Spring Framework)\n它是整个家族的核心容器\n核心能力： IoC 和 AOP 作用： 由Spring负责管理 Java 对象的生命周期，让对象之间解耦。如果没有 Spring，程序员需要手创建对象需要手动new Object()，极其难以维护 Spring MVC\n它是 Spring 框架中的一个Web 模块\n核心能力： 基于 Servlet 规范，实现了 MVC（Model-View-Controller）设计模式 核心组件： DispatcherServlet（前端控制器） 作用： 专门解决 WEB 开发的问题。它负责拦截用户发来的浏览器请求，分发给对应的 Java 方法处理，并返回数据或页面 注意： 它是 Spring 的一部分，不是独立于 Spring 存在的。 Spring Boot\n对Spring的一种封装，是Spring的脚手架，它集成了Spring内的各种功能，并且是一套 “约定大于配置”的工具集。\n它没有创造新的技术（底层还是 Spring MVC, Spring Core），但它通过依赖管理和自动配置，把 Spring 家族原本零散的功能，打包成了一个可以直接运行的“脚手架”，让开发更专注于Spring应用的开发，无需过多关心XML的配置和底层的实现\n核心能力： 自动配置 + 起步依赖（Starter）+ 内嵌服务器（Tomcat/Jetty）\n快速搭建结构，保持稳定，SpringBoot强的地方在于版本管理，有一个父级配置文件，里面写死了几百种常用库的最佳兼容版本号，写代码时，引入依赖就不需要再写版本号，默认会使用SpringBoot规定的最佳版本号\n作用：\n简化配置： 以前用 Spring + SpringMVC，需要配置 web.xml, applicationContext.xml 等一堆文件。Spring Boot 通过扫描你的 jar 包，自动帮你把这些都配好了\n简化部署： 它把 Tomcat 这种 Web 服务器直接塞进了 jar 包里，你运行 java -jar 就能启动网站，不用再去独立安装 Tomcat\n🥱如何理解 “约定大于配置” ？\n不仅仅把核心的功能打包好，而且默认规定了一套规则，程序员开发过程中的约定，大部分都遵守这套规则，如果没有特殊的要求，那就按照默认的规则执行如：\nweb应用的端口号默认是8080\n代码写在哪里？只要你的代码放在主启动类（Main Application）所在的包或者子包下面，我就能扫描到\n静态资源（图片/JS/CSS）放哪里？Spring Boot 约定只要你把文件扔在 src/main/resources/static 文件夹里，我就直接对外开放访问\n总结：约定大于配置 = 系统自带一套“最佳实践”的默认值\n如果没特殊需求，就可以开箱即用 有特殊需求：在application.properties里手动配置，灵活度高 一句话总结：Spring MVC 和 Spring Boot 都属于Spring，Spring MVC 是 Spring的一个MVC 框架，Spring Boot 则是基于 Spring 的一套快速开发整合包（脚手架）\n‍\n","date":"2025-12-08T17:12:08+08:00","image":"https://Jul1en-Lin.github.io/p/spring-ioc-di/assets/image-20251202182824-baismlb_hu_18985df30c2dfb0f.png","permalink":"https://Jul1en-Lin.github.io/p/spring-ioc-di/","title":"🍀Spring IoC \u0026 DI"}]